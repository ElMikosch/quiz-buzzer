#include <Arduino.h>
#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h>
#include <Preferences.h>
#include "protocol.h"
#include "config.h"

#ifdef ENABLE_WEBSOCKET
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <DNSServer.h>
#include <WebSocketsServer.h>
#include <ArduinoJson.h>
#include <ESPmDNS.h>
#endif

// ============================================================================
// GAME STATE MACHINE
// ============================================================================

enum GameState {
  STATE_READY,          // Waiting for first press, all buzzers active
  STATE_LOCKED,         // One buzzer pressed, all others locked out
  STATE_PARTIAL_LOCKOUT // Wrong answer given, that buzzer locked, others can try
};

GameState currentState = STATE_READY;
uint8_t selectedBuzzer = 0;        // 1-4, or 0 if none
uint8_t lockedBuzzers = 0;         // Bitmask: bit 0 = buzzer 1, bit 1 = buzzer 2, etc.
unsigned long lastPressTime = 0;   // For timestamp-based tie breaking

// Known buzzer node MAC addresses (custom MACs set on buzzer nodes)
uint8_t buzzerMACs[NUM_BUZZERS][6] = {
  {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x01},
  {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x02},
  {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x03},
  {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x04}
};

// Control button state management
bool lastCorrectState = HIGH;
bool lastWrongState = HIGH;
bool lastResetState = HIGH;
unsigned long lastCorrectDebounce = 0;
unsigned long lastWrongDebounce = 0;
unsigned long lastResetDebounce = 0;

// Serial message queue
String messageQueue[MESSAGE_QUEUE_SIZE];
int queueHead = 0;
int queueTail = 0;
int queueCount = 0;

// Connection tracking
unsigned long lastHeartbeatTime = 0;
unsigned long nodeLastSeen[NUM_BUZZERS] = {0, 0, 0, 0};
bool nodeConnected[NUM_BUZZERS] = {false, false, false, false};

// Serial command input
char serialInputBuffer[SERIAL_INPUT_BUFFER_SIZE];
int serialInputIndex = 0;

// NVS storage for WiFi credentials
Preferences preferences;

#ifdef ENABLE_WEBSOCKET
// Web server and DNS server for captive portal
AsyncWebServer* webServer = nullptr;
DNSServer* dnsServer = nullptr;

// WiFi mode state machine
enum WiFiMode {
  SETUP_MODE,      // AP mode for initial configuration
  STATION_MODE,    // Connected to WiFi network
  CONNECTING       // Attempting to connect
};

WiFiMode currentWiFiMode = SETUP_MODE;
unsigned long lastWiFiCheck = 0;
unsigned long connectionAttemptStart = 0;

// WebSocket server
WebSocketsServer* webSocketServer = nullptr;

// WebSocket client connection tracking
uint8_t connectedClients[WEBSOCKET_MAX_CLIENTS];
uint8_t numConnectedClients = 0;

// Forward declarations for game state handlers (needed by webSocketEvent)
void handleCorrectAnswer();
void handleWrongAnswer();
void handleFullReset();
#endif

// ============================================================================
// SERIAL MESSAGE QUEUE
// ============================================================================

void queueMessage(const String& msg) {
  if (queueCount < MESSAGE_QUEUE_SIZE) {
    messageQueue[queueTail] = msg;
    queueTail = (queueTail + 1) % MESSAGE_QUEUE_SIZE;
    queueCount++;
  } else {
    Serial.println("WARNING: Message queue full, dropping message");
  }
}

void processMessageQueue() {
  while (queueCount > 0) {
    Serial.println(messageQueue[queueHead]);
    queueHead = (queueHead + 1) % MESSAGE_QUEUE_SIZE;
    queueCount--;
  }
}

// ============================================================================
// UNIFIED MESSAGE BROADCASTING (Section 11)
// ============================================================================

// Broadcasts a message to both USB serial (original format) and WebSocket (JSON format)
// serialMsg: Original serial format message (e.g., "BUZZER:1", "CORRECT")
// jsonMsg: JSON formatted message for WebSocket clients
void broadcastMessage(const String& serialMsg, const String& jsonMsg) {
  // Always send to serial (backward compatibility)
  queueMessage(serialMsg);
  
#ifdef ENABLE_WEBSOCKET
  // Send to WebSocket clients if available
  if (webSocketServer != nullptr && currentWiFiMode == STATION_MODE) {
    for (uint8_t i = 0; i < numConnectedClients; i++) {
      if (!webSocketServer->sendTXT(connectedClients[i], jsonMsg)) {
        Serial.print("DEBUG: WS: Failed to send to client ");
        Serial.println(connectedClients[i]);
      }
    }
  }
#endif
}

// ============================================================================
// WIFI CREDENTIALS STORAGE (NVS)
// ============================================================================

bool hasWiFiCredentials() {
  preferences.begin("wifi", true); // Read-only mode
  bool hasSSID = preferences.isKey("ssid");
  preferences.end();
  return hasSSID;
}

bool loadWiFiCredentials(String& ssid, String& password) {
  preferences.begin("wifi", true); // Read-only mode
  
  if (!preferences.isKey("ssid")) {
    preferences.end();
    return false;
  }
  
  ssid = preferences.getString("ssid", "");
  password = preferences.getString("password", "");
  preferences.end();
  
  return ssid.length() > 0;
}

bool saveWiFiCredentials(const String& ssid, const String& password) {
  preferences.begin("wifi", false); // Read-write mode
  
  bool success = true;
  success &= preferences.putString("ssid", ssid) > 0;
  success &= preferences.putString("password", password) >= 0; // Password can be empty
  
  preferences.end();
  
  if (success) {
    Serial.println("WiFi credentials saved to NVS");
  } else {
    Serial.println("ERROR: Failed to save WiFi credentials to NVS");
  }
  
  return success;
}

void clearWiFiCredentials() {
  preferences.begin("wifi", false); // Read-write mode
  preferences.clear();
  preferences.end();
  Serial.println("WiFi credentials cleared from NVS");
}

#ifdef ENABLE_WEBSOCKET
// ============================================================================
// WIFI CONFIGURATION WEB INTERFACE
// ============================================================================

const char CONFIG_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuizBuzzer Setup</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 500px;
      width: 100%;
      padding: 40px;
    }
    h1 {
      color: #667eea;
      font-size: 28px;
      margin-bottom: 10px;
      text-align: center;
    }
    .subtitle {
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      font-size: 14px;
    }
    .section {
      margin-bottom: 25px;
    }
    label {
      display: block;
      color: #333;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 14px;
    }
    input, select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }
    button {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 10px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .scan-btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    .message {
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
      display: none;
    }
    .message.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .message.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .message.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 10px;
      vertical-align: middle;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading {
      display: none;
      text-align: center;
      color: #666;
      margin-top: 20px;
    }
    .status {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 25px;
      font-size: 13px;
      color: #555;
    }
    .status-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .status-item:last-child {
      margin-bottom: 0;
    }
    .status-label {
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîå QuizBuzzer Setup</h1>
    <p class="subtitle">Configure WiFi connection</p>
    
    <div id="message" class="message"></div>
    
    <div class="status" id="status">
      <div class="status-item">
        <span class="status-label">Status:</span>
        <span id="statusText">Loading...</span>
      </div>
    </div>
    
    <form id="wifiForm">
      <div class="section">
        <label for="ssid">WiFi Network</label>
        <select id="ssid" name="ssid" required>
          <option value="">Select a network...</option>
        </select>
        <button type="button" id="scanBtn" class="scan-btn">üîç Scan Networks</button>
      </div>
      
      <div class="section">
        <label for="password">Password</label>
        <input type="password" id="password" name="password" placeholder="Enter WiFi password">
      </div>
      
      <button type="submit" id="saveBtn">üíæ Save & Connect</button>
    </form>
    
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <span>Connecting to WiFi...</span>
    </div>
    
    <button type="button" id="resetBtn" style="background: linear-gradient(135deg, #f5576c 0%, #c92a3a 100%); margin-top: 20px;">
      üîÑ Reset WiFi Settings
    </button>
  </div>
  
  <script>
    const messageEl = document.getElementById('message');
    const statusTextEl = document.getElementById('statusText');
    const wifiForm = document.getElementById('wifiForm');
    const ssidSelect = document.getElementById('ssid');
    const scanBtn = document.getElementById('scanBtn');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');
    const loadingEl = document.getElementById('loading');
    
    function showMessage(text, type) {
      messageEl.textContent = text;
      messageEl.className = 'message ' + type;
      messageEl.style.display = 'block';
      setTimeout(() => {
        messageEl.style.display = 'none';
      }, 5000);
    }
    
    async function loadStatus() {
      try {
        const response = await fetch('/status');
        const data = await response.json();
        statusTextEl.textContent = data.connected ? `Connected to ${data.ssid}` : 'Not connected';
      } catch (error) {
        statusTextEl.textContent = 'Setup mode';
      }
    }
    
    async function scanNetworks() {
      scanBtn.disabled = true;
      scanBtn.textContent = '‚è≥ Scanning...';
      
      try {
        const response = await fetch('/scan');
        const networks = await response.json();
        
        ssidSelect.innerHTML = '<option value="">Select a network...</option>';
        networks.forEach(network => {
          const option = document.createElement('option');
          option.value = network.ssid;
          option.textContent = `${network.ssid} (${network.rssi} dBm)`;
          ssidSelect.appendChild(option);
        });
        
        showMessage(`Found ${networks.length} networks`, 'success');
      } catch (error) {
        showMessage('Failed to scan networks', 'error');
      }
      
      scanBtn.disabled = false;
      scanBtn.textContent = 'üîç Scan Networks';
    }
    
    wifiForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const ssid = ssidSelect.value;
      const password = document.getElementById('password').value;
      
      if (!ssid) {
        showMessage('Please select a network', 'error');
        return;
      }
      
      saveBtn.disabled = true;
      loadingEl.style.display = 'block';
      wifiForm.style.display = 'none';
      
      try {
        const response = await fetch('/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ssid, password })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showMessage('WiFi configured! Device will restart and connect...', 'success');
          setTimeout(() => {
            window.location.href = 'http://quizbuzzer.local';
          }, 3000);
        } else {
          showMessage('Failed to save credentials', 'error');
          saveBtn.disabled = false;
          loadingEl.style.display = 'none';
          wifiForm.style.display = 'block';
        }
      } catch (error) {
        showMessage('Connection error', 'error');
        saveBtn.disabled = false;
        loadingEl.style.display = 'none';
        wifiForm.style.display = 'block';
      }
    });
    
    resetBtn.addEventListener('click', async () => {
      if (!confirm('Reset WiFi settings? Device will restart in setup mode.')) return;
      
      try {
        await fetch('/reset', { method: 'POST' });
        showMessage('Settings reset! Device restarting...', 'info');
        setTimeout(() => {
          window.location.reload();
        }, 2000);
      } catch (error) {
        showMessage('Failed to reset', 'error');
      }
    });
    
    scanBtn.addEventListener('click', scanNetworks);
    
    // Load initial status
    loadStatus();
    
    // Auto-scan on page load
    scanNetworks();
  </script>
</body>
</html>
)rawliteral";

void setupWebServer() {
  if (webServer) return; // Already initialized
  
  webServer = new AsyncWebServer(HTTP_PORT);
  
  // Serve configuration page
  webServer->on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send_P(200, "text/html", CONFIG_HTML);
  });
  
  // WiFi scan endpoint
  webServer->on("/scan", HTTP_GET, [](AsyncWebServerRequest *request) {
    int n = WiFi.scanNetworks();
    String json = "[";
    
    for (int i = 0; i < n; i++) {
      if (i > 0) json += ",";
      json += "{";
      json += "\"ssid\":\"" + WiFi.SSID(i) + "\",";
      json += "\"rssi\":" + String(WiFi.RSSI(i)) + ",";
      json += "\"secure\":" + String(WiFi.encryptionType(i) != WIFI_AUTH_OPEN);
      json += "}";
    }
    
    json += "]";
    WiFi.scanDelete();
    request->send(200, "application/json", json);
  });
  
  // Save WiFi credentials endpoint
  webServer->on("/save", HTTP_POST, [](AsyncWebServerRequest *request) {}, NULL,
    [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
      String body = String((char*)data).substring(0, len);
      
      // Simple JSON parsing (minimal, no library needed for this simple case)
      int ssidStart = body.indexOf("\"ssid\":\"") + 8;
      int ssidEnd = body.indexOf("\"", ssidStart);
      int passStart = body.indexOf("\"password\":\"") + 12;
      int passEnd = body.indexOf("\"", passStart);
      
      if (ssidStart > 7 && ssidEnd > ssidStart) {
        String ssid = body.substring(ssidStart, ssidEnd);
        String password = "";
        
        if (passStart > 11 && passEnd > passStart) {
          password = body.substring(passStart, passEnd);
        }
        
        bool success = saveWiFiCredentials(ssid, password);
        
        String response = success ? 
          "{\"success\":true,\"message\":\"Credentials saved\"}" :
          "{\"success\":false,\"message\":\"Failed to save\"}";
        
        request->send(200, "application/json", response);
        
        if (success) {
          Serial.println("WiFi credentials saved, restarting in 2 seconds...");
          delay(2000);
          ESP.restart();
        }
      } else {
        request->send(400, "application/json", "{\"success\":false,\"message\":\"Invalid request\"}");
      }
    });
  
  // Status endpoint
  webServer->on("/status", HTTP_GET, [](AsyncWebServerRequest *request) {
    String ssid, password;
    bool hasCredentials = loadWiFiCredentials(ssid, password);
    bool connected = WiFi.status() == WL_CONNECTED;
    
    String json = "{";
    json += "\"connected\":" + String(connected ? "true" : "false") + ",";
    json += "\"ssid\":\"" + (connected ? WiFi.SSID() : "") + "\",";
    json += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
    json += "\"hasCredentials\":" + String(hasCredentials ? "true" : "false");
    json += "}";
    
    request->send(200, "application/json", json);
  });
  
  // Reset WiFi endpoint
  webServer->on("/reset", HTTP_POST, [](AsyncWebServerRequest *request) {
    clearWiFiCredentials();
    request->send(200, "application/json", "{\"success\":true,\"message\":\"Credentials cleared\"}");
    
    Serial.println("WiFi reset requested, restarting in 2 seconds...");
    delay(2000);
    ESP.restart();
  });
  
  // Start server
  webServer->begin();
  Serial.println("‚úì Web server started on port " + String(HTTP_PORT));
}

void setupCaptivePortal() {
  if (dnsServer) return; // Already initialized
  
  dnsServer = new DNSServer();
  
  // Redirect all DNS requests to the AP's IP address (192.168.4.1)
  IPAddress apIP;
  apIP.fromString(WIFI_AP_IP);
  dnsServer->start(53, "*", apIP);
  
  Serial.println("‚úì Captive portal DNS started");
}

void processCaptivePortal() {
  if (dnsServer) {
    dnsServer->processNextRequest();
  }
}

// ============================================================================
// WEBSOCKET EVENT HANDLER
// ============================================================================

void webSocketEvent(uint8_t clientId, WStype_t type, uint8_t* payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      {
        Serial.print("DEBUG: WS: Client disconnected: ");
        Serial.println(clientId);
        
        // Remove client from connected clients array
        for (uint8_t i = 0; i < numConnectedClients; i++) {
          if (connectedClients[i] == clientId) {
            // Shift remaining clients down
            for (uint8_t j = i; j < numConnectedClients - 1; j++) {
              connectedClients[j] = connectedClients[j + 1];
            }
            numConnectedClients--;
            break;
          }
        }
        
        Serial.print("DEBUG: WS: Active clients: ");
        Serial.println(numConnectedClients);
      }
      break;
      
    case WStype_CONNECTED:
      {
        IPAddress ip = webSocketServer->remoteIP(clientId);
        Serial.print("DEBUG: WS: Client connected: ");
        Serial.print(clientId);
        Serial.print(" from ");
        Serial.println(ip.toString());
        
        // Add client to tracking array
        if (numConnectedClients < WEBSOCKET_MAX_CLIENTS) {
          connectedClients[numConnectedClients++] = clientId;
          Serial.print("DEBUG: WS: Active clients: ");
          Serial.println(numConnectedClients);
          
          // Send current state to newly connected client
          // Format: {"type":"state","selected":<id>,"locked":<bitmask>,"state":"<STATE_NAME>","timestamp":<ms>}
          String stateName = "READY";
          if (currentState == STATE_LOCKED) {
            stateName = "LOCKED";
          } else if (currentState == STATE_PARTIAL_LOCKOUT) {
            stateName = "PARTIAL_LOCKOUT";
          }
          
          String stateJson = "{\"type\":\"state\",\"selected\":" + String(selectedBuzzer) + 
                           ",\"locked\":" + String(lockedBuzzers) + 
                           ",\"state\":\"" + stateName + "\"" +
                           ",\"timestamp\":" + String(millis()) + "}";
          
          webSocketServer->sendTXT(clientId, stateJson);
          Serial.print("DEBUG: WS: Sent state sync to client ");
          Serial.print(clientId);
          Serial.print(": ");
          Serial.println(stateJson);
        } else {
          Serial.println("WARNING: WS: Max clients reached, rejecting connection");
          webSocketServer->disconnect(clientId);
        }
      }
      break;
      
    case WStype_TEXT:
      {
        Serial.print("DEBUG: WS: Message from client ");
        Serial.print(clientId);
        Serial.print(": ");
        Serial.println((char*)payload);
        
        // Parse JSON command
        // Expected format: {"command":"CORRECT"} or {"command":"WRONG"} or {"command":"RESET"}
        String message = String((char*)payload);
        message.trim();
        
        // Simple JSON parsing for command field
        int commandStart = message.indexOf("\"command\":\"");
        if (commandStart >= 0) {
          commandStart += 11; // Length of "command":""
          int commandEnd = message.indexOf("\"", commandStart);
          
          if (commandEnd > commandStart) {
            String command = message.substring(commandStart, commandEnd);
            command.trim();
            
            if (command == "CORRECT") {
              Serial.println("DEBUG: WS: CMD_ACK:CORRECT");
              handleCorrectAnswer();
            } else if (command == "WRONG") {
              Serial.println("DEBUG: WS: CMD_ACK:WRONG");
              handleWrongAnswer();
            } else if (command == "RESET") {
              Serial.println("DEBUG: WS: CMD_ACK:RESET");
              handleFullReset();
            } else {
              Serial.print("DEBUG: WS: CMD_ERR:UNKNOWN:");
              Serial.println(command);
            }
          } else {
            Serial.println("DEBUG: WS: CMD_ERR:INVALID_JSON");
          }
        } else {
          Serial.println("DEBUG: WS: CMD_ERR:NO_COMMAND_FIELD");
        }
      }
      break;
      
    case WStype_BIN:
      Serial.print("DEBUG: WS: Binary message received (");
      Serial.print(length);
      Serial.println(" bytes) - ignored");
      break;
      
    case WStype_ERROR:
      Serial.print("DEBUG: WS: Error on client ");
      Serial.println(clientId);
      break;
      
    case WStype_PING:
      Serial.print("DEBUG: WS: Ping from client ");
      Serial.println(clientId);
      break;
      
    case WStype_PONG:
      Serial.print("DEBUG: WS: Pong from client ");
      Serial.println(clientId);
      break;
      
    default:
      Serial.print("DEBUG: WS: Unknown event type: ");
      Serial.println(type);
      break;
  }
}

// ============================================================================
// JSON MESSAGE FORMATTING
// ============================================================================

String formatBuzzerJson(uint8_t id) {
  String json = "{\"type\":\"buzzer\",\"id\":";
  json += String(id);
  json += ",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

String formatCorrectJson() {
  String json = "{\"type\":\"correct\",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

String formatWrongJson() {
  String json = "{\"type\":\"wrong\",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

String formatResetJson() {
  String json = "{\"type\":\"reset\",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

String formatDisconnectJson(uint8_t id) {
  String json = "{\"type\":\"disconnect\",\"id\":";
  json += String(id);
  json += ",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

String formatReconnectJson(uint8_t id) {
  String json = "{\"type\":\"reconnect\",\"id\":";
  json += String(id);
  json += ",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

String formatStateJson(uint8_t selected, uint8_t lockedBitmask) {
  String json = "{\"type\":\"state\",\"selected\":";
  json += String(selected);
  json += ",\"locked\":";
  json += String(lockedBitmask);
  json += ",\"state\":\"";
  
  // Add current game state name
  switch (currentState) {
    case STATE_READY:
      json += "READY";
      break;
    case STATE_LOCKED:
      json += "LOCKED";
      break;
    case STATE_PARTIAL_LOCKOUT:
      json += "PARTIAL_LOCKOUT";
      break;
    default:
      json += "UNKNOWN";
      break;
  }
  
  json += "\",\"timestamp\":";
  json += String(millis());
  json += "}";
  return json;
}

// ============================================================================
// WIFI MODE STATE MACHINE
// ============================================================================

bool checkWiFiResetButton() {
  // Check if RESET button (GPIO 27) is held during boot
  unsigned long startTime = millis();
  bool buttonHeld = true;
  
  while (millis() - startTime < WIFI_RESET_BUTTON_HOLD_MS) {
    if (digitalRead(CTRL_BUTTON_RESET) == HIGH) {
      // Button released before 3 seconds
      buttonHeld = false;
      break;
    }
    delay(10);
  }
  
  return buttonHeld;
}

void enterSetupMode() {
  Serial.println("========================================");
  Serial.println("ENTERING SETUP MODE");
  Serial.println("========================================");
  
  currentWiFiMode = SETUP_MODE;
  
  // Configure WiFi AP
  WiFi.mode(WIFI_AP_STA); // AP + STA to allow ESP-NOW on channel 1
  
  IPAddress apIP, gateway, subnet;
  apIP.fromString(WIFI_AP_IP);
  gateway.fromString(WIFI_AP_GATEWAY);
  subnet.fromString(WIFI_AP_SUBNET);
  
  WiFi.softAPConfig(apIP, gateway, subnet);
  WiFi.softAP(WIFI_SETUP_SSID, WIFI_SETUP_PASSWORD, WIFI_AP_CHANNEL);
  
  Serial.println("‚úì WiFi AP started");
  Serial.print("  SSID: ");
  Serial.println(WIFI_SETUP_SSID);
  Serial.print("  IP Address: ");
  Serial.println(WiFi.softAPIP());
  Serial.println("  Open this address in a browser to configure WiFi");
  
  // Start captive portal DNS
  setupCaptivePortal();
  
  // Start web server
  setupWebServer();
  
  Serial.println("========================================");
  Serial.println("SETUP MODE READY");
  Serial.println("Connect to 'QuizBuzzer-Setup' network");
  Serial.println("========================================");
}

void enterStationMode() {
  Serial.println("========================================");
  Serial.println("ENTERING STATION MODE");
  Serial.println("========================================");
  
  currentWiFiMode = CONNECTING;
  
  // Load credentials from NVS
  String ssid, password;
  if (!loadWiFiCredentials(ssid, password)) {
    Serial.println("‚úó No WiFi credentials found, entering setup mode");
    enterSetupMode();
    return;
  }
  
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  
  // Set WiFi mode to STA (allows ESP-NOW to continue working)
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid.c_str(), password.c_str());
  
  connectionAttemptStart = millis();
  unsigned long timeout = WIFI_CONNECT_TIMEOUT_MS;
  
  // Wait for connection with timeout
  while (WiFi.status() != WL_CONNECTED && (millis() - connectionAttemptStart < timeout)) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  
  if (WiFi.status() == WL_CONNECTED) {
    // Successfully connected
    currentWiFiMode = STATION_MODE;
    
    Serial.println("‚úì WiFi connected!");
    Serial.print("  SSID: ");
    Serial.println(WiFi.SSID());
    Serial.print("  IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("  Channel: ");
    Serial.println(WiFi.channel());
    
    // Start mDNS responder
    if (MDNS.begin(MDNS_HOSTNAME)) {
      Serial.print("‚úì mDNS responder started: ");
      Serial.print(MDNS_HOSTNAME);
      Serial.println(".local");
      
      // Advertise WebSocket service
      MDNS.addService("ws", "tcp", WEBSOCKET_PORT);
      Serial.print("‚úì mDNS service advertised: _ws._tcp on port ");
      Serial.println(WEBSOCKET_PORT);
    } else {
      Serial.println("‚úó Error starting mDNS responder");
    }
    
    // Initialize WebSocket server
    webSocketServer = new WebSocketsServer(WEBSOCKET_PORT);
    webSocketServer->begin();
    webSocketServer->onEvent(webSocketEvent);
    Serial.print("‚úì WebSocket server started on port ");
    Serial.println(WEBSOCKET_PORT);
    
    Serial.println("========================================");
    Serial.println("STATION MODE ACTIVE");
    Serial.println("========================================");
  } else {
    // Connection failed
    Serial.println("‚úó WiFi connection failed");
    Serial.println("  Falling back to Setup Mode");
    enterSetupMode();
  }
}

void checkWiFiConnection() {
  if (currentWiFiMode != STATION_MODE) {
    return; // Only monitor in STATION_MODE
  }
  
  unsigned long now = millis();
  
  // Check connection every 5 seconds
  if (now - lastWiFiCheck < WIFI_RECONNECT_INTERVAL_MS) {
    return;
  }
  
  lastWiFiCheck = now;
  
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi disconnected, attempting reconnect...");
    WiFi.reconnect();
    
    // Wait briefly for reconnection
    delay(5000);
    
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi reconnection failed, entering setup mode");
      enterSetupMode();
    }
  }
}

#endif // ENABLE_WEBSOCKET

// ============================================================================
// LED CONTROL
// ============================================================================

void sendLEDCommand(uint8_t nodeId, LEDState state) {
  if (nodeId < 1 || nodeId > NUM_BUZZERS) return;

  BuzzerMessage msg;
  msg.node_id = nodeId;
  msg.msg_type = MSG_LED_COMMAND;
  msg.value = state;
  msg.timestamp = millis();

  esp_now_send(buzzerMACs[nodeId - 1], (uint8_t*)&msg, sizeof(msg));
}

void updateAllLEDs() {
  for (uint8_t i = 1; i <= NUM_BUZZERS; i++) {
    if (currentState == STATE_READY) {
      // All LEDs on in ready state
      sendLEDCommand(i, LED_ON);
    } else if (currentState == STATE_LOCKED) {
      // Selected buzzer blinks, others off
      if (i == selectedBuzzer) {
        sendLEDCommand(i, LED_BLINK);
      } else {
        sendLEDCommand(i, LED_OFF);
      }
    } else if (currentState == STATE_PARTIAL_LOCKOUT) {
      // Selected buzzer blinks, locked buzzers off, active buzzers on
      if (i == selectedBuzzer) {
        sendLEDCommand(i, LED_BLINK);
      } else if (lockedBuzzers & (1 << (i - 1))) {
        sendLEDCommand(i, LED_OFF);
      } else {
        sendLEDCommand(i, LED_ON);
      }
    }
  }
}

// ============================================================================
// CONNECTION MONITORING & HEARTBEAT
// ============================================================================

void broadcastHeartbeat() {
  BuzzerMessage msg;
  msg.node_id = 0; // 0 = broadcast from controller
  msg.msg_type = MSG_HEARTBEAT;
  msg.value = 0;
  msg.timestamp = millis();

  // Send to each buzzer individually (more reliable than broadcast)
  for (int i = 0; i < NUM_BUZZERS; i++) {
    esp_now_send(buzzerMACs[i], (uint8_t*)&msg, sizeof(msg));
  }
}

void updateNodeConnection(uint8_t nodeId) {
  if (nodeId < 1 || nodeId > NUM_BUZZERS) return;
  
  unsigned long now = millis();
  bool wasConnected = nodeConnected[nodeId - 1];
  nodeLastSeen[nodeId - 1] = now;
  nodeConnected[nodeId - 1] = true;

  if (!wasConnected) {
    // Node reconnected
    Serial.print("RECONNECT:");
    Serial.println(nodeId);
  }
}

void checkNodeTimeouts() {
  unsigned long now = millis();
  
  for (uint8_t i = 0; i < NUM_BUZZERS; i++) {
    if (nodeConnected[i]) {
      if (now - nodeLastSeen[i] > CONNECTION_TIMEOUT_MS) {
        // Node timed out
        nodeConnected[i] = false;
        Serial.print("DISCONNECT:");
        Serial.println(i + 1);
      }
    }
  }
}

void sendStateSync(uint8_t nodeId) {
  if (nodeId < 1 || nodeId > NUM_BUZZERS) return;

  BuzzerMessage msg;
  msg.node_id = nodeId;
  msg.msg_type = MSG_STATE_SYNC;
  msg.timestamp = millis();
  
  // Pack game state into value field:
  // Bits 0-3: locked buzzers bitmask
  // Bits 4-6: selected buzzer (0-4)
  // Bit 7: game state mode (0=LOCKED, 1=PARTIAL_LOCKOUT)
  msg.value = lockedBuzzers | (selectedBuzzer << 4);
  if (currentState == STATE_PARTIAL_LOCKOUT) {
    msg.value |= 0x80; // Set bit 7 for PARTIAL_LOCKOUT
  }

  esp_now_send(buzzerMACs[nodeId - 1], (uint8_t*)&msg, sizeof(msg));
  
  Serial.print("STATE_SYNC:");
  Serial.print(nodeId);
  Serial.print(" (state=");
  Serial.print(currentState);
  Serial.print(", selected=");
  Serial.print(selectedBuzzer);
  Serial.print(", locked=0x");
  Serial.print(lockedBuzzers, HEX);
  Serial.println(")");
}

// ============================================================================
// GAME STATE HANDLERS
// ============================================================================

void handleBuzzerPress(uint8_t nodeId, uint32_t timestamp) {
  if (nodeId < 1 || nodeId > NUM_BUZZERS) return;

  // Check if this buzzer is locked out
  if (lockedBuzzers & (1 << (nodeId - 1))) {
    Serial.print("Buzzer ");
    Serial.print(nodeId);
    Serial.println(" is locked out, ignoring press");
    return;
  }

  if (currentState == STATE_READY || currentState == STATE_PARTIAL_LOCKOUT) {
    // Accept the press
    selectedBuzzer = nodeId;
    currentState = STATE_LOCKED;
    lastPressTime = timestamp;

    Serial.print("Buzzer ");
    Serial.print(nodeId);
    Serial.println(" pressed and locked in");

    // Send to PC
    queueMessage("BUZZER:" + String(nodeId));

    // Update LEDs: selected blinks, others off
    updateAllLEDs();
  } else if (currentState == STATE_LOCKED) {
    // Already locked, ignore subsequent presses
    Serial.print("System locked, ignoring press from buzzer ");
    Serial.println(nodeId);
  }
}

void handleCorrectAnswer() {
  if (selectedBuzzer == 0) {
    Serial.println("No buzzer selected, ignoring CORRECT command");
    return;
  }

  Serial.println("CORRECT answer - resetting to READY");
  
  // Reset to ready state
  currentState = STATE_READY;
  selectedBuzzer = 0;
  lockedBuzzers = 0;

  // Send to PC
  queueMessage("CORRECT");

  // All LEDs on
  updateAllLEDs();
}

void handleWrongAnswer() {
  if (selectedBuzzer == 0) {
    Serial.println("No buzzer selected, ignoring WRONG command");
    return;
  }

  Serial.print("WRONG answer from buzzer ");
  Serial.print(selectedBuzzer);
  Serial.println(" - entering PARTIAL_LOCKOUT");

  // Lock out the wrong buzzer
  lockedBuzzers |= (1 << (selectedBuzzer - 1));
  
  // Check if all buzzers are now locked
  if (lockedBuzzers == 0x0F) { // All 4 buzzers locked (bits 0-3 set)
    Serial.println("All buzzers locked out, resetting to READY");
    currentState = STATE_READY;
    selectedBuzzer = 0;
    lockedBuzzers = 0;
  } else {
    // Enter partial lockout state
    currentState = STATE_PARTIAL_LOCKOUT;
    selectedBuzzer = 0; // Clear selection so another buzzer can try
  }

  // Send to PC
  queueMessage("WRONG");

  // Update LEDs
  updateAllLEDs();
}

void handleFullReset() {
  Serial.println("FULL RESET - clearing all state");

  // Reset everything
  currentState = STATE_READY;
  selectedBuzzer = 0;
  lockedBuzzers = 0;

  // Send to PC
  queueMessage("RESET");

  // All LEDs on
  updateAllLEDs();
}

// ============================================================================
// ESP-NOW CALLBACKS
// ============================================================================

void onDataReceive(const uint8_t *mac, const uint8_t *data, int len) {
  if (len != sizeof(BuzzerMessage)) {
    Serial.println("ERROR: Received message with wrong size");
    return;
  }

  BuzzerMessage msg;
  memcpy(&msg, data, sizeof(msg));

  // Update connection tracking for any message from a node
  updateNodeConnection(msg.node_id);

  // Process message based on type
  if (msg.msg_type == MSG_BUTTON_PRESS) {
    handleBuzzerPress(msg.node_id, msg.timestamp);
  } else if (msg.msg_type == MSG_STATE_REQUEST) {
    // Node is requesting current game state (reconnection)
    Serial.print("State request from node ");
    Serial.println(msg.node_id);
    sendStateSync(msg.node_id);
  }
}

void onDataSent(const uint8_t *mac, esp_now_send_status_t status) {
  // LED commands are fire-and-forget, no need to handle send status
  // Could add retry logic here if needed
}

// ============================================================================
// CONTROL BUTTON HANDLING
// ============================================================================

void handleControlButtons() {
  // Handle CORRECT button
  int correctReading = digitalRead(CTRL_BUTTON_CORRECT);
  if (correctReading != lastCorrectState) {
    lastCorrectDebounce = millis();
  }
  if ((millis() - lastCorrectDebounce) > DEBOUNCE_DELAY_MS) {
    if (correctReading == LOW) { // Button pressed (pullup)
      handleCorrectAnswer();
      while (digitalRead(CTRL_BUTTON_CORRECT) == LOW) delay(10); // Wait for release
    }
  }
  lastCorrectState = correctReading;

  // Handle WRONG button
  int wrongReading = digitalRead(CTRL_BUTTON_WRONG);
  if (wrongReading != lastWrongState) {
    lastWrongDebounce = millis();
  }
  if ((millis() - lastWrongDebounce) > DEBOUNCE_DELAY_MS) {
    if (wrongReading == LOW) {
      handleWrongAnswer();
      while (digitalRead(CTRL_BUTTON_WRONG) == LOW) delay(10);
    }
  }
  lastWrongState = wrongReading;

  // Handle RESET button
  int resetReading = digitalRead(CTRL_BUTTON_RESET);
  if (resetReading != lastResetState) {
    lastResetDebounce = millis();
  }
  if ((millis() - lastResetDebounce) > DEBOUNCE_DELAY_MS) {
    if (resetReading == LOW) {
      handleFullReset();
      while (digitalRead(CTRL_BUTTON_RESET) == LOW) delay(10);
    }
  }
  lastResetState = resetReading;
}

// ============================================================================
// SERIAL COMMAND INPUT
// ============================================================================

void handleSerialInput() {
  while (Serial.available() > 0) {
    char c = Serial.read();
    
    // Handle newline characters (command terminator)
    if (c == '\n' || c == '\r') {
      // Only process if buffer has content
      if (serialInputIndex > 0) {
        // Null-terminate the command string
        serialInputBuffer[serialInputIndex] = '\0';
        
        // Parse and execute the command
        String command(serialInputBuffer);
        command.trim(); // Remove any whitespace
        
        if (command == "CORRECT") {
          Serial.println("CMD_ACK:CORRECT");
          handleCorrectAnswer();
        } else if (command == "WRONG") {
          Serial.println("CMD_ACK:WRONG");
          handleWrongAnswer();
        } else if (command == "RESET") {
          Serial.println("CMD_ACK:RESET");
          handleFullReset();
        } else if (command.length() > 0) {
          // Unknown command
          Serial.print("CMD_ERR:UNKNOWN:");
          Serial.println(command);
        }
        
        // Reset buffer for next command
        serialInputIndex = 0;
      }
    } else {
      // Add character to buffer if there's space
      if (serialInputIndex < SERIAL_INPUT_BUFFER_SIZE - 1) {
        serialInputBuffer[serialInputIndex++] = c;
      } else {
        // Buffer overflow - discard and report error
        Serial.println("CMD_ERR:BUFFER_OVERFLOW");
        serialInputIndex = 0;
      }
    }
  }
}

// ============================================================================
// SETUP AND MAIN LOOP
// ============================================================================

void setup() {
  // Initialize serial for PC communication
  Serial.begin(SERIAL_BAUD_RATE);
  delay(1000);

  Serial.println("========================================");
  Serial.println("MAIN CONTROLLER");
  Serial.println("========================================");

  // Configure control button pins
  pinMode(CTRL_BUTTON_CORRECT, INPUT_PULLUP);
  pinMode(CTRL_BUTTON_WRONG, INPUT_PULLUP);
  pinMode(CTRL_BUTTON_RESET, INPUT_PULLUP);

#ifdef ENABLE_WEBSOCKET
  // WiFi mode selection (must happen before ESP-NOW initialization)
  bool resetButtonHeld = checkWiFiResetButton();
  
  if (resetButtonHeld) {
    // User held RESET button during boot - clear credentials and enter setup mode
    Serial.println("RESET button held - clearing WiFi credentials");
    clearWiFiCredentials();
    enterSetupMode();
  } else if (hasWiFiCredentials()) {
    // Credentials exist - attempt to connect to WiFi
    enterStationMode();
  } else {
    // No credentials - enter setup mode for first-time configuration
    enterSetupMode();
  }
#else
  // WebSocket disabled - use standard WiFi STA mode for ESP-NOW only
  WiFi.mode(WIFI_STA);
#endif

  // Set custom MAC address (AA:BB:CC:DD:EE:00 for main controller)
#ifndef ENABLE_WEBSOCKET
  WiFi.mode(WIFI_STA);
#endif
  uint8_t customMAC[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x00};
  esp_err_t macResult = esp_wifi_set_mac(WIFI_IF_STA, customMAC);

  Serial.print("Custom MAC address: ");
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", customMAC[i]);
    if (i < 5) Serial.print(":");
  }
  Serial.println();

  if (macResult == ESP_OK) {
    Serial.println("‚úì Custom MAC address set successfully");
  } else {
    Serial.println("‚úó ERROR: Failed to set custom MAC address");
  }

  // Initialize ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("‚úó ERROR: ESP-NOW initialization failed");
    return;
  }
  Serial.println("‚úì ESP-NOW initialized");

  // Register callbacks
  esp_now_register_send_cb(onDataSent);
  esp_now_register_recv_cb(onDataReceive);

  // Add all buzzer nodes as peers
  for (int i = 0; i < NUM_BUZZERS; i++) {
    esp_now_peer_info_t peerInfo = {};
    memcpy(peerInfo.peer_addr, buzzerMACs[i], 6);
    peerInfo.channel = ESPNOW_CHANNEL;
    peerInfo.encrypt = false;

    if (esp_now_add_peer(&peerInfo) != ESP_OK) {
      Serial.print("‚úó ERROR: Failed to add buzzer ");
      Serial.print(i + 1);
      Serial.println(" as peer");
    } else {
      Serial.print("‚úì Buzzer ");
      Serial.print(i + 1);
      Serial.println(" added as peer");
    }
  }

  Serial.println("========================================");
  Serial.println("Main controller ready!");
  Serial.println("Initializing all LEDs to ON (READY state)");
  Serial.println("========================================");

  // Initialize all LEDs to ON
  delay(500); // Give buzzer nodes time to initialize
  updateAllLEDs();
}

void loop() {
  // Broadcast heartbeat periodically
  unsigned long now = millis();
  if (now - lastHeartbeatTime >= HEARTBEAT_INTERVAL_MS) {
    broadcastHeartbeat();
    lastHeartbeatTime = now;
  }

  // Check for node timeouts
  checkNodeTimeouts();

#ifdef ENABLE_WEBSOCKET
  // Monitor WiFi connection and handle reconnection if needed
  checkWiFiConnection();
  
  // Process captive portal DNS requests in setup mode
  processCaptivePortal();
  
  // Process WebSocket events in station mode
  if (webSocketServer != nullptr) {
    webSocketServer->loop();
  }
#endif

  handleControlButtons();
  handleSerialInput();
  processMessageQueue();
  delay(1); // Small delay to prevent watchdog issues
}
